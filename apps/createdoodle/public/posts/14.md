# Vue.js의 반응성 기법 (reactive, ref, computed)

## reactive

```typescript
const obj = reactive({
  name: 'mofupiyo',
  age: 1,
});
obj.name = 'devilmofu';

console.log(obj.name); // devilmofu
```

`reactive`의 반응성은 JavaScript의 `Proxy` 객체를 기반으로 한다.

`Proxy`는 원본 객체를 감싸 해당 객체의 속성을 읽거나 (get) 쓸 때 (set) 특정 동작을 가로채서 실행할 수 있게 해주는 JavaScript의 객체이다.

즉 `reactive`를 읽거나 쓸때 어떠한 로직을 실행할 수 있으며. 이때 Vue.js는 의존성을 수집 (track)하거나 값 업데이트를 알리는 (trigger) 로직을 실행하여 반응성을 구현한다.

```typescript
// reactive 객체
function reactive(obj) {
  // reactive 객체 속성에 접근할 때 호출
  // ex) obj.some
  return new Proxy(obj, {
    get(target, key) {
      track(target, key);
      return target[key];
    },
    set(target, key, value) {
      // reactive 객체 속성에 새 값을 할당할 때 호출
      // ex) obj.some = 'value'
      target[key] = value;
      trigger(target, key);
    },
  });
}
```

```typescript
// 이 값은 이펙트가 실행되기 직전에 설정됨
let activeEffect;

// 의존성 수집
function track(target, key) {
  if (activeEffect) {
    const effects = getSubscribersForProperty(target, key);
    effects.add(activeEffect);
  }
}

// 값 업데이트 알리미
function trigger(target, key) {
  const effects = getSubscribersForProperty(target, key);
  effects.forEach((effect) => effect()); // 이팩트를 실행
}

// effects의 구조: WeakMap<target, Map<key, Set<effect>>>
```

### reactive의 깊은 반응성

Vue.js에서 중첩 객체 같은 경우에는 어떻게 깊은 반응성을 부여하는 것일까?

`reactive`는 객체 내부의 모든 중첩 객체를 한번에 프록시로 만들지 않고, 코드에서 특정 중첩 객체에 처음 접근하는 순간, 즉 `Proxy`에서 get 핸들러를 호출할때 해당 객체를 프록시로 변환하는 Lazy 업데이트 방식을 사용한다.

이러한 방식으로 Vue.js는 불필요한 작업을 줄여 성능을 최적화한다.

## ref

```typescript
const count = ref(0);
count.value = 1;
console.log(count.value); // 1
```

`ref`의 반응성은 JavaScript 객체의 `getter/setter` 접근자를 이용하여 구현한다.

`getter/setter`는 JavaScript의 객체 속성에 접근(get) 또는 할당(set) 시 호출되는 함수를 바인딩할때 사용하는 접근자이다.

`reactive`와 동일하게 `value` 값을 읽거나 쓸 때 `track` 또는 `trigger` 로직을 실행한다.

```typescript
// value 값이 원시값일때
function ref(value) {
  const refObject = {
    // refValue.value 시 호출
    get value() {
      track(refObject, 'value');
      return value;
    },
    // refValue.value = other 시 호출
    set value(newValue) {
      value = newValue;
      trigger(refObject, 'value');
    },
  };
  return refObject;
}

// value 값이 객체일때 vue.js 로직에 따라 reactive로 변경하여 반응성 주입
function ref(value) {
  const refObject = {
    get value() {
      track(refObject, 'value');
      return reactive(value);
    },
    set value(newValue) {
      value = reactive(newValue);
      trigger(refObject, 'value');
    },
  };
  return refObject;
}
```

`ref`와 `reactive`는 밀접한 관계를 가지고 있는데,

`ref`는 객체 또는 원시값을 담는 컨테이너 역할을 하며 `value` 속성의 교체를 감지하는 역할을 한다.

`value`에 객체가 담기면 `ref`는 내부적으로 `reactive`를 호출하여 해당 객체를 프록시 객체로 자동 변환한다.

## computed

`computed`는 반응형 데이터를 포함하는 복잡한 로직에 사용되는 “계산된 속성”이다.

`computed`는 반응형 이펙트를 사용해 콜백 함수 내의 변수들을 재계산하는 특성을 가지고 있다.

즉 반응성을 가진 변수들이 `computed`의 콜백 함수에 명시되어 있으면 `computed`는 그 값들을 구독하여 반응성 변수들이 바뀔때 `computed` 계산값도 같이 업데이트된다.

```typescript
const num1 = ref(0);
const num2 = ref(0);

const sumValue = computed(() => num1.value + num2.value);

num1.value = 10;
num2.value = 20;

console.log(sumValue.value); // 30
```

`computed`의 대략적인 구현을 간단하게 표현하면 다음과 같다.

```typescript
function computed(getter) {
  let _value;

  const runner = () => {
    activeEffect = runner;
    getter(); // 의존성 수집을 위해 실행
    activeEffect = null;
  };

  // 최초 의존성 수집
  runner();

  const computedRef = {
    get value() {
      track(computedRef, 'value'); // computedRef.value에 의존하는 외부 effect를 추적
      _value = getter();
      return _value;
    },
  };
  return computedRef;
}
```

위 `computed` 예제의 실행 흐름을 간단하게 살펴보면 다음과 같다.

```typescript
// computed 변수 등록
const sumValue = computed(() => num1.value + num2.value);

let activeEffect;

// 1. computed 내부 함수 실행 흐름
function computed(getter) {
	...
	const runner = () => {
	    activeEffect = runner;
	    // 2. 콜백 함수가 실행됨
	    // getter();
	    (() => num1.value + num2.value)();
	    activeEffect = null;
	}
	...
}

// 3. num1.value와 num2.value가 읽어지면서 ref 객체의 getter 메서드 실행
// num1.value, num2.value
function ref(value) {
  const refObject = {
    get value() { // refValue.value 시 호출
      track(refObject, 'value');
      // return value
      return 0;
    },
  }
  return refObject;
}

// 4. ref 객체의 getter 메서드 안 track 함수 실행
function track(target, key) {
  // computed에서 activeEffet에 effect가 할당되었기 때문에 true로 진행
  if (activeEffect) {
    // num1 객체에 구독된 effects map을 가져옴
    // const effects = getSubscribersForProperty(target, key)
    const effects = getSubscribersForProperty(num1, 'value');
    // activeEffect를 새로운 이벤트로 추가
    effects.add(activeEffect);
  }
}

console.log(sumValue.value); // 0

// num1.value와 num2.value에 값 할당
num1.value = 10;
num2.value = 20;

// 5. num1.value와 num2.value에 값이 할당되면서 ref 객체의 setter 메서드 실행
function ref(value) {
  const refObject = {
    set value(newValue) {
      // value = newValue;
      value = 10
      // num2.value: value = 20
      // trigger 함수 실행
      trigger(refObject, 'value');
    }
  }
  return refObject
}

// 6. ref 객체의 setter 함수에서 trigger 함수 실행
function trigger(target, key) {
  // const effects = getSubscribersForProperty(target, key)
  const effects = getSubscribersForProperty(num1, 'value');
  effects.forEach((effect) => effect()); // 지금까지 등록된 effects 목록을 순회하면서 담간 effect들 실행
}

// 7. effects 목록이 순회되어 실행되면서 computed에서 등록된 activeEffect 실행
function computed(getter) {
	...
	const runner = () => {
	    activeEffect = runner;
	    // 2. 콜백 함수가 실행됨
	    // getter();
	    (() => num1.value + num2.value)();
	    activeEffect = null;
	}
	...
}

// 8. 다시 1 ~ 4번 과정 반복하여 값 업데이트

console.log(sumValue.value); // 30
```

- [**반응성의 심층 이해 (Reactivity in Depth)**](https://ko.vuejs.org/guide/extras/reactivity-in-depth.html)
- [**Proxy - MDN Web Docs**](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
- [**Object.assign() - MDN Web Docs**](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
- [**프로퍼티 getter와 setter**](https://ko.javascript.info/property-accessors)
