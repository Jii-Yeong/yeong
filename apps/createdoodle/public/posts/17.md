# C++ 4대 캐스트

## C++ 4대 캐스트의 종류

C++의 4대 캐스트는 static_cast, dynamic_cast, const_cast, reinterpret_cast로 구성되어 있다.
이들은 C-스타일 캐스트 보다 더 안전하고 의도가 명확하기 때문에 사용을 권장하고 있다.

각 캐스트는 각자 용도가 명확히 정해져있다.

## 업캐스팅 (Upcasting) 과 다운캐스팅 (Downcasting)

4대 캐스트에 대해 알아보기 전에 업캐스팅(Upcasting)과 다운캐스팅(Downcasting)에 대해 알아보자.
업캐스팅과 다운캐스팅은 클래스 상속 관계에서 포인터나 참조의 타입을 변환하는 것을 말한다. C++의 다형성(Polymorphism)에서 매우 중요한 개념이다.

동물(Animal)이라는 부모 클래스와 강아지(Dog), 고양이(Cat)라는 자식 클래스가 있다고 가정해보자.

### 업캐스팅 (Upcasting)

- 방향: 자식 클래스(Derived) ⇒ 부모 클래스(Base)
- 비유: "강아지는 동물이다." (Dog is an Animal)
- 업캐스팅은 자식 클래스의 포인터나 참조를 부모 클래스 타입으로 변환하는 것이다.
- 항상 안전한 캐스팅이다. 왜냐하면 자식 클래스는 부모 클래스의 모든 멤버(변수, 함수)를 이미 포함하고 있기 때문이다. 강아지는 동물이 가진 속성 (ex: 숨쉬기) 을 무조건 가지고 있다.
- 특징:
  - 별도의 캐스트 연산자가 필요 없이 암시적으로(implicitly) 허용되고, static_cast를 명시적으로 사용해도 가능하다.
  - 업캐스팅된 포인터로는 자식 클래스 고유의 멤버(예: Dog의 bark())에는 접근할 수 없고, 부모 클래스에 정의된 멤버(예: Animal의 breathe())에만 접근할 수 있다. 단, 가상 함수는 예외이다.

### 다운캐스팅 (Downcasting)

- 방향: 부모 클래스(Base) ⇒ 자식 클래스(Derived)
- 비유: "동물이 강아지일 것이다." (An Animal might be a Dog)
- 다운캐스팅은 부모 클래스 타입의 포인터나 참조를 자식 클래스 타입으로 변환하는 것이다.
- 잠재적으로 위험한 캐스팅이다. 부모 클래스 포인터가 실제로는 강아지가 아니라 고양이를 가리키고 있을 수도 있기 때문에 고양이를 강아지로 강제로 변환하면, 강아지만 가진 기능(예: bark())을 호출하려 할 때 심각한 문제가 발생한다.
- 특징:
  - 암시적으로 허용되지 않는다. (반드시 명시적인 캐스트가 필요함)
  - static_cast보다 dynamic_cast를 사용해야 안전하게 변환할 수 있다.

| 구분   | 업캐스팅 (Upcasting) | 다운캐스팅 (Downcasting)                |
| ------ | -------------------- | --------------------------------------- |
| 방향   | 자식 ⇒ 부모          | 부모 ⇒ 자식                             |
| 비유   | 강아지는 동물이다.   | 동물은 강아지일까?                      |
| 안정성 | 항상 안전 (Safe)     | 잠재적 위험 (Unsafe)                    |
| 방법   | 암시적, static_cast  | static_cast (위험), dynamic_cast (안전) |

## static_cast (정적 캐스트)

컴파일 타임에 타입을 변환하며, 논리적으로 관련 있는 타입 간의 변환에 사용된다.

- 주요 용도:
  - 숫자 타입 간 변환 (예: int를 float로, float를 int로)
  - 클래스 계층 구조 내에서 업캐스팅 (자식 -> 부모) (주로 명시적 표현)
  - 다운캐스팅 (부모 -> 자식)도 가능하지만, 런타임 안전 검사를 하지 않아 위험함 (프로그래머가 타입을 100% 확신할 때만 사용)
  - void\*와 다른 타입 포인터 간의 변환
- 특징: 런타임 비용(오버헤드)이 없음

### 예시

1. 기본 자료형 변환 (가장 일반적인 사용)

```cpp
#include <iostream>

int main() {
	float f_value = 10.5f;
	// float를 int로 변환. 소수점 이하가 잘린다.
	int i_value = static_cast<int>(f_value);

	std::cout << "Float: " << f_value << std::endl; // 출력: 10.5
	std::cout << "Int: " << i_value << std::endl;   // 출력: 10
}
```

1. 클래스 계층 간 변환 (업캐스팅/다운캐스팅)

```cpp
#include <iostream>

class Base {
	public:
		void speak() { std::cout << "Base" << std::endl; }
};

class Derived : public Base {
	public:
		void speak() { std::cout << "Derived" << std::endl; }
		void specialized_func() { std::cout << "Derived Only" << std::endl; }
};

int main() {
	// 1. 업캐스팅 (자식 -> 부모): 항상 안전
	Derived* d = new Derived();
	Base* b_up = static_cast<Base*>(d);
	b_up->speak(); // 출력: Base (가상 함수가 아니므로)
	// 2. 다운캐스팅 (부모 -> 자식): 프로그래머가 타입을 확신할 때
	Base* b_down = new Derived();
	Derived* d_down = static_cast<Derived*>(b_down);
	d_down->specialized_func(); // 출력: Derived Only

	// 3. 잘못된 다운캐스팅 (위험한 예)
	Base* b_only = new Base();
	// 컴파일은 되지만, 런타임에 심각한 오류 발생 가능성이 높음
	// Derived* d_wrong = static_cast<Derived*>(b_only);
	// d_wrong->specialized_func(); // 정의되지 않은 동작(Undefined Behavior)

	delete d;
	delete b_down;
	delete b_only;
}
```

## dynamic_cast (동적 캐스트)

런타임에 타입을 검사하며, 주로 클래스 계층 구조 내에서 안전한 다운캐스팅을 위해 사용된다.

- 주요 용도: 부모 클래스 포인터/참조를 자식 클래스 포인터/참조로 안전하게 변환할 때 사용한다.
- 필수 조건: 클래스가 하나 이상의 가상 함수를 포함해야 한다. (즉, 다형성(polymorphic) 클래스여야 함)
- RTTI(Run-Time Type Information)를 사용하여 dynamic cast가 가능한지 검사한다.
- 특징:
  - 변환 성공 시: 유효한 포인터 또는 참조를 반환한다.
  - 변환 실패 시:
    - 포인터의 경우: nullptr를 반환
    - 참조의 경우: std::bad_cast 예외(exception)를 발생
  - static_cast보다 런타임 비용이 있다.

### 예시

```cpp
#include <iostream>
#include <exception>

class Base {
	public:
		virtual void speak() { std::cout << "Base" << std::endl; } // 가상 함수 (필수)
		virtual ~Base() {}
};

class Derived : public Base {
	public:
		void speak() override { std::cout << "Derived" << std::endl; }
		void specialized_func() { std::cout << "Derived Only" << std::endl; }
};

class AnotherClass : public Base {
	public:
		void speak() override { std::cout << "AnotherClass" << std::endl; }
};

int main() {
	// 1. 성공하는 포인터 캐스팅
	Base* b_ptr_derived = new Derived();
	Derived* d_ptr = dynamic_cast<Derived*>(b_ptr_derived);
	if (d_ptr != nullptr) {
	    std::cout << "Pointer Cast [1] Success!" << std::endl;
	    d_ptr->specialized_func(); // 출력: Derived Only
	}

	// 2. 실패하는 포인터 캐스팅
	Base* b_ptr_another = new AnotherClass();
	Derived* d_ptr_fail = dynamic_cast<Derived*>(b_ptr_another);

	if (d_ptr_fail == nullptr) {
	    std::cout << "Pointer Cast [2] Failed! (Returns nullptr)" << std::endl;
	}

	// 3. 실패하는 참조(Reference) 캐스팅 (예외 발생)
	Base& b_ref_another = *(new AnotherClass());

	try {
	    // 실패하는 참조 캐스팅 (예외 발생)
	    Derived& d_ref_fail = dynamic_cast<Derived&>(b_ref_another);
	    std::cout << "이 메시지는 출력되지 않습니다." << std::endl;

	} catch (const std::bad_cast& e) {
	    std::cout << "Reference Cast [2] Failed! Exception: " << e.what() << std::endl;
	}

	delete b_ptr_derived;
	delete b_ptr_another;
	delete &b_ref_another;
}
```

### dynamic_cast와 RTTI, 가상 함수(virtual)의 관계

dynamic_cast가 제대로 동작하기 위해서는 가상 함수(virtual function)와 RTTI(Run-Time Type Information)가 필수적이다.
간단히 말해, virtual 키워드가 스위치를 켜면, RTTI라는 정보가 생성되고, dynamic_cast가 그 정보를 사용하는 것이다.

#### virtual 함수: 다형성의 시작

virtual 키워드는 C++에서 다형성(Polymorphism)을 구현하는 핵심 요소다.

부모 클래스 포인터가 자식 객체를 가리킬 때, virtual로 선언된 함수를 호출하면 포인터의 타입(부모)이 아닌 실제 객체의 타입(자식)에 맞는 함수가 호출된다.

#### dynamic_cast와의 관계

컴파일러는 어떤 클래스에 virtual 함수가 하나라도 선언되는 순간, “이 클래스는 다형적으로 사용될 수 있다.”라고 인지한다.

그리고 이 클래스로부터 생성되는 객체에 실제 타입이 무엇인지에 대한 정보, 즉 RTTI를 생성한다.

#### RTTI (Run-Time Type Information)

RTTI는 말 그대로 런타임에 알 수 있는 타입 정보다.
virtual 함수가 포함된 클래스의 객체에는 이 RTTI 정보가 함께 저장된다.

이 정보 안에는 "나는 사실 Animal 타입 포인터에 담겨있지만, 내 진짜 정체는 Dog야"라는 정보가 들어있다.

#### dynamic_cast: 신분증 검사기

`dynamic_cast<Dog>`(pet)을 호출하면, dynamic_cast는 다음과 같이 동작한다.

- pet 포인터가 가리키는 실제 객체에 RTTI가 있는지 확인한다.
- RTTI가 있다면, 그 정보를 읽어본다.
- 이 객체의 실제 타입이 Dog이거나, Dog의 자식 클래스인지 검사한다.
- 성공 시 (Yes): Dog\* 타입으로 변환된 주소를 반환
- 실패 시 (No): nullptr를 반환 (참조의 경우 std::bad_cast 예외 발생)

#### 핵심 메커니즘: vptr과 vtable (가상 함수 테이블)

컴파일러는 virtual 함수가 있는 클래스의 객체를 생성할 때, 객체 내부에 vptr (virtual pointer)이라는 숨겨진 포인터 멤버를 하나 추가한다.

- vptr은 vtable (virtual table)이라는 정적 테이블을 가리킨다.
- vtable은 가상 함수들의 실제 주소 목록을 가지고 있는데, 바로 이 vtable 근처에 RTTI 정보가함께 저장된다.

즉, dynamic_cast는 결국 이 vptr을 따라가서 vtable 및 RTTI 정보를 확인하고 타입 검사를 수행하는 것이다.

### 다형성 (Polymorphism) 과 다형성 클래스 (Polymorphic Class)

dynamic_cast와 RTTI의 근간이 되는 개념이 바로 다형성이다.

#### 다형성 (Polymorphism) 이란?

다형성(多形性)은 말 다양한 형태를 가질 수 있는 성질을 의미한다.
C++ 프로그래밍에서는 하나의 부모 클래스 타입(포인터 또는 참조)이 다양한 자식 클래스 객체를 가리키면서, 동일한 함수 호출에도 불구하고 실제 객체의 종류에 따라 각기 다른 동작을 하도록 하는 능력을 말한다.
하나의 타입으로 동일한 명령을 내렸지만, 실제 연결된 객체에 따라 결과(동작)가 달라지는 것이 바로 다형성이다.

#### 다형성 클래스 (Polymorphic Class) 란?

다형성 클래스는 다형성을 지원하도록 설계된 클래스를 말한다.
C++에서는 하단의 조건을 만족하면 다형성 클래스이다.

하나 이상의 가상 함수(virtual function)를 멤버로 가진 클래스

virtual 키워드로 선언된 함수가 단 하나라도 있으면, 컴파일러는 이 클래스의 객체에 vptr (가상 테이블 포인터)을 추가한다.

> 부모 클래스로 사용될 클래스(즉, 상속될 클래스)는 소멸자(destructor)를 virtual로 선언하는 것이 좋다.

```cpp
class Base {
  public:virtual ~Base() {} // 가상 소멸자//
  ...
};
```

이렇게 하면 Base 클래스는 가상 함수를 가지게 되므로 다형성 클래스가 된다.

#### 개방-폐쇄 원칙 (OCP, Open-Closed Principle)

다형성은 객체 지향 설계의 5가지 핵심 원칙인 SOLID 중 'O'를 담당하는 개방-폐쇄 원칙(OCP)을 지키는 핵심 수단이다.

> 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에는 열려(Open) 있어야 하고, 수정에는 닫혀(Closed) 있어야 한다.

- 확장에 열려 있다 (Open): 새로운 기능(예: Triangle 클래스)이 추가될 때, 기존 코드를 수정하지 않고도 시스템의 동작을 확장할 수 있어야 한다.
- 수정에 닫혀 있다 (Closed): 새로운 기능을 추가하기 위해, 기존에 잘 동작하던 코드(예: drawAllShapes 함수)를 직접 수정할 필요가 없어야 한다.

**OCP를 준수한 예시 (다형성 활용)**

```cpp
#include <iostream>
#include <vector>

// 1. 다형성 클래스 (Shape)
//    - 'virtual' 함수(draw)를 가졌으므로 다형성 클래스임
class Shape {
	public:
		virtual void draw() = 0; // 순수 가상 함수
		virtual ~Shape() {}
};

// 2. 자식 클래스 (Circle)
class Circle : public Shape {
	public:
		void draw() override {
			std::cout << "원을 그립니다. O" << std::endl;
		}
};

// 3. 자식 클래스 (Rectangle)
class Rectangle : public Shape {
	public:
		void draw() override {
			std::cout << "사각형을 그립니다. []" << std::endl;
	}
};

// 이 함수가 OCP를 준수
// 'Shape'라는 하나의 타입만 알지만, 실제로는 Circle과 Rectangle을 모두 처리
void drawAllShapes(const std::vector<Shape*>& shapes) {
	for (Shape* shape : shapes) {
	// 다형성: shape가 실제 가리키는 객체의 draw()가 호출됨
	shape->draw();
	}
}

int main() {
	std::vector<Shape*> myShapes;
	// [업캐스팅]
	myShapes.push_back(new Circle());
	myShapes.push_back(new Rectangle());
	// myShapes.push_back(new Triangle()); // 나중에 Triangle을 추가해도 이 함수는 '수정'할 필요가 없음
	drawAllShapes(myShapes);

	for (Shape* shape : myShapes) {
	    delete shape;
	}
	return 0;
}
```

- 결과: Triangle이라는 새로운 클래스를 추가해도, drawAllShapes 함수는 단 한 글자도 수정할 필요가 없다.
  - drawAllShapes 함수는 수정에는 닫혀 있다. (Closed)
  - 시스템은 Triangle이라는 확장에는 열려 있다. (Open)

## const_cast (상수성 캐스트)

포인터나 참조의 const 또는 volatile 한정자를 제거할 때만 사용한다.

- 주요 용도: const 한정자 때문에 수정이 불가능한 변수를 일시적으로 수정해야 할 때 (주로 const를 지원하지 않는 레거시 API 호출 시)
- 주의 사항:
  - 이 캐스트로 타입을 변경할 수는 없다. (예: int*를* float로 변경 불가)
  - 애초에 const로 선언된 객체의 상수성을 const_cast로 제거하고 값을 수정하려 하면, 그 결과는 정의되지 않은 동작(Undefined Behavior, UB)이다.

### 예시

```cpp
#include <iostream>

// const를 지원하지 않는 오래된 C 스타일 라이브러리 함수라고 가정
void legacy_print_function(char* str) {
	if (str) {
		std::cout << "Legacy Print: " << str << std::endl;
	}
}

int main() {
	const char* my_message = "Hello, Const!";
	// 1. const 제거 (안전한 사용 예)
	// 함수가 내부에서 값을 '수정'하지 않는다는 것을 프로그래머가 확신할 때
	char* non_const_message = const_cast<char*>(my_message);
	legacy_print_function(non_const_message);

	// 2. 위험한 사용 예 (정의되지 않은 동작, UB)
	const int const_value = 10;
	int* modifier = const_cast<int*>(&const_value);
	// *modifier = 20; 정의되지 않은 동작, 절대 하면 안됨

	std::cout << "Original const_value: " << const_value << std::endl;
}
```

## reinterpret_cast (재해석 캐스트)

가장 위험한 캐스트로, 타입과 관계없이 메모리의 비트 패턴을 그대로 재해석한다.

- 주요 용도:
  - 전혀 관련 없는 포인터 타입 간의 변환 (예: int를 float으로)
  - 포인터를 정수로, 또는 정수를 포인터로 변환
  - 하드웨어 제어 등 매우 로우레벨 프로그래밍에서 사용
- 특징: 컴파일러가 어떤 검사도 해주지 않으므로 잘못 사용하면 프로그램이 즉시 비정상 종료되거나 예측 불가능한 오류를 일으킨다.

### 예시

```cpp
#include <iostream>

int main() {
	// 1. 포인터를 완전히 다른 타입 포인터로 변환
	int int_value = 65; // 'A'의 아스키 코드

	// int*를 char*로 변환하여 메모리의 첫 바이트만 읽기
	char* char_ptr = reinterpret_cast<char*>(&int_value);
	std::cout << "Int as Char (first byte): " << *char_ptr << std::endl; // 'A' (리틀 엔디안 기준)

	// 2. 포인터를 정수로 변환 (메모리 주소 자체를 숫자로)
	int* int_ptr = &int_value;
	uintptr_t address_value = reinterpret_cast<uintptr_t>(int_ptr);
	std::cout << "Address as integer: " << std::hex << address_value << std::endl;

	// 3. 정수를 다시 포인터로 변환
	int* same_ptr = reinterpret_cast<int*>(address_value);
	std::cout << "Value via re-casted pointer: " << std::dec << *same_ptr << std::endl; // 65
}
```
