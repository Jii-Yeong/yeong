# JavaScript `Web Worker`
최근에 업무를 하면서 3000개 가량의 데이터가 담겨있는 배열을 조작해야하는 일이 빈번히 발생했다. 그 만큼 크기의 배열을 순회하며 조작하다보니 동작을 시작하면 끝날때까지 화면이 멈춰버리는 현상이 생기게 되었다. 

이를 해결하기 위해서 `Web Worker`를 사용하게 되었고, 해당 기능을 이용함으로써 무거운 작업 시 화면이 멈추는 현상을 해결하게 되었다. 

이 글에서는 왜 대량의 데이터를 조작하면 화면이 멈추는지, 어떻게 `Web Worker`가 해당 문제를 해결하였는지, `Web Worker`는 어떻게 동작하고 있는지, 다른 `비동기 Web API`들과는 어떤 차이점이 있는지를 기술해보려고 한다.

## 대량의 데이터를 조작하면 화면이 멈추는 이유 
<img src="photo/15/ui-freezing.png" width="400" />

브라우저는 대부분 싱글스레드로 돌아간다. 그래서 JavaScript 코드 실행과 UI 렌더링이 동일한 **단일 스레드 (메인 스레드) 에서 처리**가 된다. 

문제점은 JavaScript 코드 실행과 UI 렌더링이 순차적으로 싱글 스레드에서 이루어지기 때문에 JavaScript 코드에서 실행 시간이 긴 코드가 동작하면 **싱글 스레드는 그동안 UI 렌더링을 멈추게 된다.** 그래서 화면이 멈추는 일이 발생하게 되는 것이다.

## `Web Worker`로 문제 해결하기

### `Web Worker`란

`Web Worker`가 이러한 싱글 스레드 문제를 해결해준다.

`Web Worker`는 메인 스레드와 다른 **새로운 스레드**를 만들어 그 스레드에서 스크립트를 실행할 수 있게 해준다.

즉 위의 경우처럼 대량의 데이터를 처리할때 `Web Worker`를 사용하면 대량의 데이터를 처리하는 코드는 새롭게 생성된 `Web Worker` 스레드에서 돌게 하고, UI 렌더링은 메인 스레드에서 그대로 처리하게 놔두면 되기 때문에 화면 멈춤이 발생하지 않는다.

또한 `fetch()`, `XMLHttpRequest` API를 통해서 네트워크 요청을 보낼수도 있어 다양한 상황에서도 쓰일 수 있는 기능이다.

### `Web Worker`의 동작 방식

`Web Worker`는 `new Worker()` 생성자에 js 파일을 명시하여 사용된다.

js 파일에 `Web Worker`에서 처리할 작업들의 코드가 담겨있고, `Web Worker`는 해당 코드를 메인 스레드의 window 전역 컨텍스트와 분리된 백그라운드 스레드의 전역 컨텍스트에서 실행된다. 따라서 `Web Worker`에서는 **DOM에 접근하여 조작할수가 없다.**

이런 이유로 `Web Worker`는 메세지 시스템을 통해 메인 스레드에서 `Web Worker` 스레드로 데이터를 전송하거나, 그 반대로 `Web Worker` 스레드에서 메인 스레드로 데이터를 전송하는 일을 하게된다. `postMessage()` , `onmessage` 이벤트 핸들러를 통해 메세지를 주고받으며, **데이터는 공유되지 않고 복사된다.**

<br>

**간단한 리액트 예제**

```typescript
// src/worker.ts

console.log('Worker: Script loaded.');

self.onmessage = (event: MessageEvent) => {
    const message = event.data;

    console.log('Worker: Received message from main thread:', message);

    if (message === 'start_calculation') {
        let sum = 0;
        // 매우 긴 계산 작업 (예: 1부터 100억까지 더하기)
        for (let i = 0; i < 10_000_000_000; i++) {
            sum += 1;
        }
        console.log('Worker: Calculation complete. Sending result back to main thread.');
        self.postMessage(sum); // 결과 전송
    }
};
```

```tsx
// src/HeavyCalculationComponent.tsx

import React, { useState, useEffect, useRef } from 'react';
// Vite, CRA 5.x 등 최신 번들러는 이런 방식으로 워커를 import 할 수 있음.
// TypeScript를 사용하는 경우 `tsconfig.json`에 "lib": ["webworker"]가 포함되어야함.
import Worker from './worker.ts?worker'; 

const HeavyCalculationComponent: React.FC = () => {
    const [result, setResult] = useState<string>('Waiting...');
    const [inputValue, setInputValue] = useState<string>(''); // UI 반응성 테스트용 입력값
    const workerRef = useRef<Worker | null>(null); // 워커 인스턴스를 저장할 Ref

    // 컴포넌트 마운트 시 워커 생성 및 메시지 핸들러 설정
    useEffect(() => {
        // Web Worker 생성
        workerRef.current = new Worker();

        // 워커로부터 메시지를 받았을 때의 처리
        workerRef.current.onmessage = (event: MessageEvent<number>) => {
            const workerResult = event.data;
            setResult(`Calculation Complete: ${workerResult}`);
            console.log('Main: Received result from worker.');
        };

        // 워커에서 에러 발생 시 처리
        workerRef.current.onerror = (error: ErrorEvent) => {
            console.error('Main: Worker error!', error.message);
            setResult('Error during calculation!');
        };

        // 컴포넌트 언마운트 시 워커 종료 (메모리 누수 방지)
        return () => {
            if (workerRef.current) {
                workerRef.current.terminate();
                workerRef.current = null;
                console.log('Main: Worker terminated.');
            }
        };
    }, []);

    const startCalculation = () => {
        if (workerRef.current) {
            setResult('Calculating...');
            console.log('Main: Sending message to worker to start calculation.');
            workerRef.current.postMessage('start_calculation'); // 워커에게 메시지 전송
        }
    };

    return (
        <div>
            <button onClick={startCalculation}>
                Start Heavy Calculation
            </button>
            
            <p>
              <strong>Result:</strong> 
              <span>{result}</span>
            </p>
            <p>
                While the worker calculates, you can still interact with the UI. 
                Try typing here:
            </p>
            <input 
                type="text" 
                value={inputValue} 
                onChange={(e) => setInputValue(e.target.value)} 
                placeholder="Type anything..."
            />
            <p>Your input: {inputValue}</p>
        </div>
    );
};

export default HeavyCalculationComponent;
```

## JavaScript는 싱글 스레드 언어인데 `Web Worker`는 어떻게 멀티스레드로 동작하는가?

JavaScript 언어 자체는 싱글 스레드가 맞다. 즉 JavaScript 엔진(ex: v8 등)이 JavaScript 코드를 직접 실행할때는 싱글 스레드로 작동한다. 하지만 **JavaScript가 실행되는 환경(웹 브라우저, Node.js)는 여러 기능 (Web API) 과 스레드를 지원**하기 때문에 멀티스레드 동작이 가능하다.  
<br>
비동기 작업같은 경우에도 브라우저에 백그라운드 스레드가 돌아 비동기 작업에 필요한 일부 기능들을 실행하지만, JavaScript 코드 자체 (콜백 함수)는 이벤트 루프를 통해 메인 스레드에서 동작하기 때문에 **코드 실행 관점에서는 싱글 스레드로서 작동**한다.  
<br>
그러나 `Web Worker`는 브라우저에서 제공하는 기능으로 **별도의 스레드를 생성하여 병렬 작업을 가능하게 한다.** `Web Worker`로 전달된 JavaScript 코드는 별도로 생성된 스레드에서 실행되기 때문에 `Web Worker`는 **코드 실행 관점에서도 멀티 스레드로 동작**한다고 볼 수 있다.

## 비동기 Web API (`setTimeout`, `Promise`)과 다른 점

``setTimeout``이나 ``Promise`` 같은 비동기 함수들은 `Web Worker`처럼 별도의 스레드를 새로 만들지 않는다. 대신 브라우저의 기존 기능(타이머, 네트워크)에 작업을 위임하고, 완료되면 이벤트 루프를 통해 결과를 받는 **동시성** 모델을 사용한다. 반면 `Web Worker`는 실제 스레드를 생성하는 **병렬성** 모델이다.


### `setTimeout()`의 동작 방식

1. 메인 스레드에서 `setTimeout` 실행 ⇒ Web API가 인자로 넘긴 밀리세컨드 만큼 타이머를 잼
2. 메인 스레드는 바로 다음 코드를 실행
3. 타이머가 끝나면 Web API가 **이벤트 루프**를 통해 **테스크 큐**에 콜백 함수를 넣음
4. 메인 스레드가 하던 일이 끝나면 **테스크 큐에 있는 콜백 함수 작업을 꺼내 실행**

### `Promise`의 동작 방식

1. 메인 스레드가 Web API에다가 서버에서 데이터를 가져와달라고 요청
2. Web API는 브라우저 네트워크 기능을 통해 서버에서 데이터를 가져오도록 요청하고, 메인 스레드에게 `pending` 중인 프로미스 객체를 넘겨줌
3. 메인 스레드는 `pending` 중인 프로미스 객체만 받은 뒤 바로 다음 코드 실행
4. 서버에서 데이터를 성공적으로 가져오면 Web API는 이벤트 루프를 통해 `Promise` 객체의 상태를 `resolved`로 바꾸고, 실패하면 `rejected`로 변경하여 테스크 큐에 올림
5. 메인 스레드는 하던 일이 끝나면 테스크 큐를 보고 성공이면 `.then()` 안의 콜백 함수를 실행, 실패면 `.catch()` 안 콜백 함수를 실행

### 동시성과 병렬성

- **동시성 (Concurrency)**: 한 번에 여러 일을 다루는 것. 싱글 코어에서 작업을 번갈아 처리해 동시에 진행되는 것처럼 보이게 한다. (`setTimeout`, `Promise`)
- **병렬성 (Parallelism)**: 한 번에 여러 일을 실제로 동시에 처리하는 것. 멀티 코어 환경에서 여러 스레드가 각자 작업을 실행한다. (`Web Worker`)

<br>

| 구분 | `Web Worker` | `setTimeout` / `Promise` |
| --- | --- | --- |
| **스레드** | 진짜 **별도의 스레드 생성** | 별도 스레드 없이 **기존 브라우저 기능 활용** |
| **작업 종류** | CPU를 많이 쓰는 **무겁고 복잡한 계산** | 시간 지연, 네트워크 통신 등 **간단한 비동기 작업** |
| **자원 소모** | 스레드 생성 비용이 커서 **비교적 비쌈** | 기존 기능을 활용해 **가볍고 저렴함** |

<br>

결론적으로, `setTimeout`과 `Promise`는 **메인 스레드를 막지 않는(Non-blocking) 비동기 작업**이라는 점은 `Web Worker`와 같지만, **실제로 별도의 스레드를 만들어 코드를 실행하지는 않는다**는 점에서 결정적인 차이가 존재한다.   
즉 `setTimeout`과 `Promise`는 실제 작업(콜백 함수 실행)은 여전히 **단 하나의 메인 스레드**에서 처리된다.

## 싱글 코어와 CPU와 `Web Worker`

### 싱글 코어 CPU

CPU 코어가 **싱글 코어**면 메인 스레드와 `Web Worker` 스레드가 **하나의 코어를 나눠서 써야한다.**

싱글 코어일때는 **시분할(Time-Slicing) 방식**을 사용하여 아주 짧은 시간 (예: 0.01초) 단위로 코어를 번갈아가며 사용한다.

이 전환 과정(컨텍스트 스위칭)은 워낙 빨라서 **마치 두 코드가 동시에 실행되는것처럼 보인다.**

### 싱글 코어에서 `Web Worker`를 쓰는 이유

싱글 코어에서 `Web Worker`를 사용하면, 즉 멀티 스레드가 동작하면 사실 동시성과 **총 실행 시간은 같거나, 오히려 스레드들이 코어를 주고받는 시간 때문에 약간 더 걸릴수도** 있다.  
<br>
그럼에도 사용하는 이유는, 싱글 스레드로 시간이 오래 걸리는 작업을 하면 싱글 스레드가 하던 UI 상호작용이 멈추기 때문에 프리징이 발생하게 되지만 **멀티 스레드로 작업하면 프리징이 되지 않아** 더욱 향상된 사용자 경험을 줄 수 있기 때문이다.

### 출처
- [웹페이지를 표시한다는 것: 브라우저는 어떻게 동작하는가](https://developer.mozilla.org/ko/docs/Web/Performance/Guides/How_browsers_work)
- [Using Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#web_workers_api)