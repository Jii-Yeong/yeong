# C++ 포인터와 참조

## 포인터

포인터는 **메모리주소**를 값으로 가지는 특별한 변수이다.

일반 변수가 데이터를 직접 저장하는 반면, 포인터는 그 데이터가 저장되어있는 주소를 저장한다.

### 기본 사용법: `&` 와 `*`

포인터를 사용하려면 두 개의 연산자를 알아야한다.

1. **`&` (주소 연산자)**: 변수 앞에 붙여 그 변수의 메모리 주소를 가져온다.
2. **`*` (역참조 연산자)**: 포인터 변수 앞에 붙여, 그 포인터가 가리키는 주소에 실제로 저장된 값에 접근한다.

```cpp
#include <iostream>

int main() {
    int number = 20;

    // 역참조 연산자를 이용한 포인터 변수 선언
    int* ptr;

    // 포인터에 주소 할당
    // 주소 연산자를 이용하여 number 변수의 메모리 주소(&)를 ptr에 저장
    ptr = &number;

    // 포인터 값(주소) 출력
    std::cout << ptr << std::endl;

    // 역참조(*)를 통한 값 접근으로 20이 출력
    // ptr이 가리키는 주소(number)로 찾아가서(*) 그 안의 값을 읽음
    std::cout << *ptr << std::endl;

    // 역참조(*)를 통한 값 변경
    // ptr이 가리키는 주소(number)로 찾아가서(*) 그 값을 50으로 변경
    *ptr = 50;

    // number 변수 자체가 50으로 변경
    std::cout number << std::endl;
    return 0;
}
```

## 포인터를 왜 사용하는가

### 1. 동적 메모리 할당

- 프로그램 실행 중에 필요한 만큼 메모리를 할당받을 때 사용한다.
- `new` 키워드는 메모리를 할당하고 그 시작 주소를 반환하는데, 이 주소를 포인터에 저장해야 한다.
- 다 쓴 메모리는 `delete` 키워드로 직접 해제해야 메모리 누수가 발생하지 않는다.

```cpp
// 실행 중에 정수 하나를 저장할 공간을 '힙(Heap)' 메모리에 만듬
int* dynamicInt = new int;
*dynamicInt = 100;

// 사용이 끝나면 반드시 해제해야함
delete dynamicInt;
```

#### 동적 메모리 할당의 위험성

동적 메모리 할당을 잘못 사용하면 프로그램이 즉시 다운되거나 알 수 없는 버그를 만들수가 있다.

- **댕글링 포인터**: 이미 `delete`로 해제된 메모리를 가리키는 포인터
- **널 포인터 역참조**: `nullptr`을 가리키는 포인터를 역참조하려고 시도하는 경우에 발생
- **메모리 누수**: `new`로 할당한 메모리를 `delete`로 해제하는 것을 잊어버리는 경우에 발생

#### 현대 C++의 스마트 포인터(Smart Pointer)

위와 같은 위험 때문에 C++11 이후에서는 `new`와 `delete`를 직접 사용하는 **원시 포인터(Raw Pointer)** 사용을 최소화한다.

대신 스마트 포인터(Smart Pointer)를 사용한다.

스마트 포인터는 포인터처럼 동작하지만, 자신이 가리키는 메모리를 자동으로 해제해준다.

1. **`std::unique_ptr` (고유 포인터)**
   - 오직 하나의 포인터만이 특정 객체를 소유
   - `unique_ptr`가 범위를 벗어나거나(예: 함수 종료) 파괴될 때, 가리키던 메모리를 **자동으로 `delete`** 해줌
   - 소유권 이전(Move)은 가능하지만 복사는 불가능
2. **`std::shared_ptr` (공유 포인터)**
   - 여러 포인터가 하나의 객체를 함께 소유(공유) 할 수 있음
   - 내부적으로 '참조 카운트(Reference Count)'를 관리
   - 해당 객체를 가리키는 `shared_ptr`가 0개가 되면, 즉 **마지막 소유자가 사라질 때** 메모리를 자동으로 `delete` 해줌

### 2. 효율적인 함수 인자 전달

- 함수에 큰 데이터(예: 거대한 구조체나 클래스 객체)를 전달할 때, 데이터를 전부 복사하면 성능이 저하된다.
- 이때 데이터의 주소(포인터)만 전달하면, 주소 값만 복사되므로 매우 빠른 속도를 보여준다.
- 또한, 함수 안에서 포인터를 통해 원본 데이터를 직접 수정할 수 있다. (C++에서는 이 용도로 후술할 참조(Reference, `&`)를 더 선호하기도 한다.)

```cpp
// 포인터를 받아 값을 1 증가시키는 함수
void addOne(int* p) {
    (*p)++; // *p = *p + 1;
}

int main() {
    int value = 5;
    addOne(&value); // val의 '주소'를 넘김
    std::cout << value << std::endl; // 6이 출력됨
}
```

## 참조

C++의 참조(Reference)는 **이미 존재하는 변수에 대한 '별명'을 만드는 기능이다.**

포인터가 다른 변수의 '주소'를 값으로 가지는 독립된 변수라면, 참조는 **그 변수 자체의 또 다른 이름**이 된다.

### 참조(Reference)의 기본 사용법

참조는 선언되는 즉시 다른 변수의 '별명'이 되며, 그 이후로는 원본 변수와 완전히 똑같이 작동한다.

```cpp
#include <iostream>

int main() {
    int original = 10;

    // 참조 선언 및 초기화
    // original 변수의 '별명'으로 ref를 선언
    // 'ref'는 'original'의 또 다른 이름이 됨
    int& ref = original;

    // 값 확인
    // 둘은 이름만 다를 뿐 같은 값을 출력함
    std::cout << original << std::endl; // 10
    std::cout <<< ref << std::endl; // 10

    // '별명'을 통한 값 변경
    // '별명'인 ref의 값을 바꾸면 '본체'인 original의 값도 바뀜
    ref = 20;
    std::cout << original << std::endl; // 20

    // '본체'를 통한 값 변경
    // '별명'인 ref의 값도 당연히 바뀜
    original = 30;
    std::cout << ref << std::endl;     // 30

    return 0;
}
```

## 참조는 언제 사용하는가

참조의 가장 주된 용도는 **함수의 매개변수**로 전달할 때이다.

### 참조에 의한 호출 (Call-by-Reference)

함수에 변수를 '별명'으로 전달하여, 함수 내에서 **원본 변수를 직접 수정**할 수 있게 한다.

```cpp
// 포인터를 사용한 방식
void swap_ptr(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 참조를 사용한 방식 (훨씬 간결함)
void swap_ref(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;

    // 포인터 방식: 주소를 넘기고(&), 안에서 역참조(*) 해야 함
    swap_ptr(&x, &y);

    int m = 5, n = 10;

    // 참조 방식: 그냥 변수를 넘기면 '별명'으로 전달됨
    // 코드가 훨씬 깔끔하고 직관적
    swap_ref(m, n); // m과 n이 10, 5로 바뀜
}
```

## 불필요한 복사 방지 (`const` 참조)

함수에 크기가 큰 객체(클래스, 구조체, `std::string`, `std::vector` 등)를 값으로 전달하면, 전체 데이터가 복사되는 큰 비용이 발생한다.

이때 **`const` 참조**를 사용하면, 복사 없이 '별명'만 전달하여 **성능을 높이면서** 함수 내에서 원본을 수정하지 못하게 막을 수 있다.

```cpp
// 비효율적인 방식: string 객체가 통째로 복사됨
void printString_copy(std::string str) {
    std::cout << str << std::endl;
}

// 효율적인 방식: 'const 참조'로 별명만 전달 (복사 X)
// const 키워드로 함수 내에서 수정(예: str = "...")도 방지함
void printString_ref(const std::string& str) {
    std::cout << str << std::endl;
}

int main() {
    std::string my_long_string = "매우... 긴... 문자열...";

    printString_copy(my_long_string); // 복사 발생
    printString_ref(my_long_string);  // 복사 안 함 (훨씬 빠름)
}
```

## 함수의 효율적인 인자 전달을 위해 포인터와 참조를 사용하는 이유: 값에 의한 호출 (Pass-by-Value)

### 값에 의한 호출 (Pass-by-Value)

함수에 값을 넘길 때 기본적으로 복사본을 만들어 전달하는 방식을 **"값에 의한 호출 (Pass-by-Value)"**이라고 부른다. 이것이 기본값인 이유는 사이드 이팩트를 방지하기 위해서이다.

**"함수는 전달받은 값을 마음대로 바꿔도 원본에 영향을 주지 않아야 한다." 가** C++(그리고 C언어)가 가진 기본적인 철학이다.

**값에 의한 호출**은 함수가 외부의 데이터(원본)를 실수로 망가뜨리는 것을 원천적으로 차단하는, 매우 안전한 방법으로 고안된 것이다.

#### 단점: 복사 비용 발생

값에 의한 호출은 복사라는 비용이 든다.

`int`나 `double` 같은 기본 타입(4~8바이트)을 복사하는 것은 별 비용이 들지 않으나, 파라미터가 10,000개의 항목을 가진 `std::vector`나 거대한 3D 모델 객체인 경우 이들을 통째로 복사하는 것은 **시간도 오래 걸리고 메모리도 낭비**하게 된다.

이와 같은 이유로 포인터나 참조(&)가 필요하다. 기본적으로는 사이드 이팩트를 발생시키지 않으면서 복사라는 비용을 줄이거나 함수 외부의 데이터 변경이 필요할 때 명시적으로 사용하여 안정성과 성능 두 부분을 지킬 수 있다.

## 이중 포인터 (`**`) 와 Rvalue (`&&`) 참조

### 이중 포인터 (`**`)

이중 ‘포인터는 포인터를 가리키는 포인터’ 이다. Pointer-to-pointer라고 부른다.

- `int var = 10;` : `var`는 **정수(int)**
- `int* ptr = &var;` : `ptr`은 '정수를 가리키는 **포인터(int\*)**' (`ptr`의 값은 `var`의 주소)
- `int** pptr = &ptr;` : `pptr`은 '정수 포인터를 가리키는 **이중 포인터(int\*\*)**' (`pptr`의 값은 `ptr`의 주소)

### Rvalue 참조 (`&&`)

Rvalue 참조 `&&`는 C++11부터 도입된, 포인터/참조와 관련된 고급 기능으로서 기존 참조 `&` (Lvalue 참조) 처럼 이름이 있는 변수의 별명이 되는게 아니라, 이름이 없고 곧 사라질 임시 값 (Rvalue, 오른쪽 값의 별명이 된다.

- `&` (Lvalue 참조): `int& ref = var;`
  - ref의 별명이 됨
- `&&` (Rvalue 참조): `int&& rref = 10;`
  - 임시 값 10의 별명이 됨

#### 사용 이유: 복사 대신 이동

Rvalue 참조를 사용하는 이유는 복사 대신 이동을 하기 위해서다.

Rvalue 참조 `&&` 는 함수가 참조된 값은 임시값이니 이 데이터를 복사하지 말고 그냥 이동만 해도 된다고 알려려주는 표시로 쓰인다.

`std::string`이나 `std::vector` 같은 무거운 객체들이 내부적으로 이 Rvalue 참조를 이용해서, 불필요한 복사 대신 효율적인 '이동'을 수행한다.
